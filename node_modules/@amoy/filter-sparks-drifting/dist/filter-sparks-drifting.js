/*!
 * @amoy/filter-sparks-drifting - v3.0.21
 * Compiled Thu, 21 Nov 2019 07:47:39 UTC
 *
 * @amoy/filter-sparks-drifting is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(t,e){"use strict";var n="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",o="\nvarying vec2 vTextureCoord;//passed from vect shader \n\nuniform sampler2D uSampler;// 2d texture\nuniform vec4 filterArea;\n\nuniform float uHeight;\nuniform float uWidth;\nuniform float uStrength;\nuniform float uTime;\n\n#define iResolution filterArea\n#define iTime uTime\n#define texture texture2D\n\n//模拟汽油燃烧\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//\t\t\t\t\t\t\t noise functions.\n//\t\t\tAuthor : Ian McEwan, Ashima Arts.\n//\tMaintainer : ijm\n//\t\t Lastmod : 20110822 (ijm)\n//\t\t License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//\t\t\t\t\t\t\t Distributed under the MIT License. See LICENSE file.\n//\t\t\t\t\t\t\t https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x){\n\treturn x-floor(x*(1./289.))*289.;\n}\n\nvec4 mod289(vec4 x){\n\treturn x-floor(x*(1./289.))*289.;\n}\n\nvec4 permute(vec4 x){\n\treturn mod289(((x*34.)+1.)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n\treturn 1.79284291400159-.85373472095314*r;\n}\n\nfloat snoise(vec3 v)\n{\n\tconst vec2 C=vec2(1./6.,1./3.);\n\tconst vec4 D=vec4(0.,.5,1.,2.);\n\t\n\t// First corner\n\tvec3 i=floor(v+dot(v,C.yyy));\n\tvec3 x0=v-i+dot(i,C.xxx);\n\t\n\t// Other corners\n\tvec3 g=step(x0.yzx,x0.xyz);\n\tvec3 l=1.-g;\n\tvec3 i1=min(g.xyz,l.zxy);\n\tvec3 i2=max(g.xyz,l.zxy);\n\t\n\t//\t x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//\t x1 = x0 - i1\t+ 1.0 * C.xxx;\n\t//\t x2 = x0 - i2\t+ 2.0 * C.xxx;\n\t//\t x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1=x0-i1+C.xxx;\n\tvec3 x2=x0-i2+C.yyy;// 2.0*C.x = 1/3 = C.y\n\tvec3 x3=x0-D.yyy;// -1.0+3.0*C.x = -0.5 = -D.y\n\t\n\t// Permutations\n\ti=mod289(i);\n\tvec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));\n\t\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_=.142857142857;// 1.0/7.0\n\tvec3 ns=n_*D.wyz-D.xzx;\n\t\n\tvec4 j=p-49.*floor(p*ns.z*ns.z);//\tmod(p,7*7)\n\t\n\tvec4 x_=floor(j*ns.z);\n\tvec4 y_=floor(j-7.*x_);// mod(j,N)\n\t\n\tvec4 x=x_*ns.x+ns.yyyy;\n\tvec4 y=y_*ns.x+ns.yyyy;\n\tvec4 h=1.-abs(x)-abs(y);\n\t\n\tvec4 b0=vec4(x.xy,y.xy);\n\tvec4 b1=vec4(x.zw,y.zw);\n\t\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0=floor(b0)*2.+1.;\n\tvec4 s1=floor(b1)*2.+1.;\n\tvec4 sh=-step(h,vec4(0.));\n\t\n\tvec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n\tvec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n\t\n\tvec3 p0=vec3(a0.xy,h.x);\n\tvec3 p1=vec3(a0.zw,h.y);\n\tvec3 p2=vec3(a1.xy,h.z);\n\tvec3 p3=vec3(a1.zw,h.w);\n\t\n\t//Normalise gradients\n\t//vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tvec4 norm=inversesqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n\tp0*=norm.x;\n\tp1*=norm.y;\n\tp2*=norm.z;\n\tp3*=norm.w;\n\t\n\t// Mix final noise value\n\tvec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n\tm=m*m;\n\treturn 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));\n}\n\n//////////////////////////////////////////////////////////////\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat prng(in vec2 seed){\n\tseed=fract(seed*vec2(5.3983,5.4427));\n\tseed+=dot(seed.yx,seed.xy+vec2(21.5351,14.3137));\n\treturn fract(seed.x*seed.y*95.4337);\n}\n\n//////////////////////////////////////////////////////////////\n\nfloat PI=3.1415926535897932384626433832795;\n\nfloat noiseStack(vec3 pos,int octaves,float falloff){\n\tfloat noise=snoise(vec3(pos));\n\tfloat off=1.;\n\tif(octaves>1){\n\t\tpos*=2.;\n\t\toff*=falloff;\n\t\tnoise=(1.-off)*noise+off*snoise(vec3(pos));\n\t}\n\tif(octaves>2){\n\t\tpos*=2.;\n\t\toff*=falloff;\n\t\tnoise=(1.-off)*noise+off*snoise(vec3(pos));\n\t}\n\tif(octaves>3){\n\t\tpos*=2.;\n\t\toff*=falloff;\n\t\tnoise=(1.-off)*noise+off*snoise(vec3(pos));\n\t}\n\treturn(1.+noise)/2.;\n}\n\nvec2 noiseStackUV(vec3 pos,int octaves,float falloff,float diff){\n\tfloat displaceA=noiseStack(pos,octaves,falloff);\n\tfloat displaceB=noiseStack(pos+vec3(3984.293,423.21,5235.19),octaves,falloff);\n\treturn vec2(displaceA,displaceB);\n}\n\nvoid main(){\n\tfloat time=iTime;\n\tvec2 resolution=iResolution.xy;\n\tvec2 fragCoord=vTextureCoord*filterArea.xy;\n\tvec2 offset=vec2(0.);\n\t//\n\tfloat xpart=fragCoord.x/resolution.x;\n\tfloat ypart=fragCoord.y/resolution.y;\n\t//\n\tfloat clip=uHeight;\n\tfloat ypartClip=1.0 - fragCoord.y/clip;//开始Y方向\n\tfloat ypartClippedFalloff=clamp(2.-ypartClip,0.,1.);//【0-1】\n\tfloat ypartClipped=min(ypartClip,1.);\n\tfloat ypartClippedn=1.-ypartClipped;\n\t//X方向油量\n\tfloat xfuel=pow(1.-abs(2.*xpart-1.),(1.0 - (uWidth/resolution.x))*5.0);\n\t//\n\tfloat timeSpeed=.5;\n\tfloat realTime=timeSpeed*time;\n\t//\n\tvec2 coordScaled=.01*fragCoord-.02*vec2(offset.x,0.);\n\tvec3 position=vec3(coordScaled,0.)+vec3(1223.,6434.,8425.);\n\tvec3 flow=vec3(4.1*(.5-xpart)*pow(ypartClippedn,4.),-2.*xfuel*pow(ypartClippedn,64.),0.);\n\tvec3 timing=realTime*vec3(0.,1.7,1.1)+flow;\n\t//\n\tvec3 displacePos=vec3(1.,.5,1.)*2.4*position+realTime*vec3(.01,.7,1.3);\n\tvec3 displace3=vec3(noiseStackUV(displacePos,2,.4,.1),0.);\n\t//\n\tvec3 noiseCoord=(vec3(2.,1.,1.)*position+timing+.4*displace3)/1.;\n\tfloat noise=noiseStack(noiseCoord,3,.4);\n\t//\n\tfloat flames=pow(ypartClipped,.3*xfuel)*pow(noise,.3*xfuel);\n\t//\n\tfloat f=ypartClippedFalloff*pow(1.-flames*flames*flames,8.);\n\tfloat fff=f*f*f;\n\tvec3 fire=uStrength*vec3(f,fff,fff*fff);\n\t\n\t// smoke\n\tfloat smokeNoise=.5+snoise(.4*position+timing*vec3(1.,1.,.2))/2.;\n\tvec3 smoke=vec3(.3*pow(xfuel,3.)*pow(ypart,2.)*(smokeNoise+.4*(1.-noise)));\n\t\n\t// sparks\n\tfloat sparkGridSize=30.*uStrength;\n\tvec2 sparkCoord=0.0 - fragCoord-vec2(2.*offset.x,190.*realTime);\n\tsparkCoord-=30.*noiseStackUV(.01*vec3(sparkCoord,30.*time),1,.4,.1);\n\tsparkCoord+=100.*flow.xy;\n\tif(mod(sparkCoord.y/sparkGridSize,2.)<1.)sparkCoord.x+=.5*sparkGridSize;\n\tvec2 sparkGridIndex=vec2(floor(sparkCoord/sparkGridSize));\n\tfloat sparkRandom=prng(sparkGridIndex);\n\tfloat sparkLife=min(10.*(1.-min((sparkGridIndex.y+(190.*realTime/sparkGridSize))/(24.-20.*sparkRandom),1.)),1.);\n\tvec3 sparks=vec3(0.);\n\tif(sparkLife>0.){\n\t\tfloat sparkSize=xfuel*xfuel*sparkRandom*.08;\n\t\tfloat sparkRadians=999.*sparkRandom*2.*PI+2.*time;\n\t\tvec2 sparkCircular=vec2(sin(sparkRadians),cos(sparkRadians));\n\t\tvec2 sparkOffset=(.5-sparkSize)*sparkGridSize*sparkCircular;\n\t\tvec2 sparkModulus=mod(sparkCoord+sparkOffset,sparkGridSize)-.5*vec2(sparkGridSize);\n\t\tfloat sparkLength=length(sparkModulus);\n\t\tfloat sparksGray=max(0.,1.-sparkLength/(sparkSize*sparkGridSize));\n\t\tsparks=sparkLife*sparksGray*vec3(0.9333, 0.498, 0.1412);\n\t}\n\t//\n\tvec4 effect = vec4(max(fire,sparks)+smoke,1.);\n\teffect.a = effect.r;\n\tgl_FragColor = effect + texture2D(uSampler, vTextureCoord);\n}",i=function(t){function e(e,i,r,s){void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=2),void 0===s&&(s=0),t.call(this,n,o),this.height=e,this.width=i,this.strength=r,this.delta=s}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var i={width:{configurable:!0},height:{configurable:!0},strength:{configurable:!0},delta:{configurable:!0}};return e.prototype.apply=function(t,e,n,o){this.uniforms.uWidth=this.width,this.uniforms.uHeight=this.height,this.uniforms.uStrength=this.strength,this.uniforms.uTime=this.delta,t.applyFilter(this,e,n,o)},i.width.get=function(){return this.uniforms.uWidth},i.width.set=function(t){this.uniforms.uWidth=t},i.height.get=function(){return this.uniforms.uHeight},i.height.set=function(t){this.uniforms.uHeight=t},i.strength.get=function(){return this.uniforms.uStrength},i.strength.set=function(t){this.uniforms.uStrength=t},i.delta.get=function(){return this.uniforms.uTime},i.delta.set=function(t){this.uniforms.uTime=t},Object.defineProperties(e.prototype,i),e}(e.Filter);return t.AmoySparksDriftingFilter=i,t}({},PIXI);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=filter-sparks-drifting.js.map
