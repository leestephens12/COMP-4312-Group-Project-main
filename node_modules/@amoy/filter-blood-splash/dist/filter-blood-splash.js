/*!
 * @amoy/filter-blood-splash - v3.0.24
 * Compiled Wed, 27 Nov 2019 03:13:09 UTC
 *
 * @amoy/filter-blood-splash is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(o,e){"use strict";var t="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",n="varying vec2 vTextureCoord;//passed from vect shader \n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;// 2d texture\n\nuniform float uPosx;\nuniform float uPosy;\nuniform float uTime;\nuniform vec3 uColor;\n\n#define SEED 0.12345679\n#define GRAV vec2(0.,-.26)\n#define SIZE 0.024\n#define DIE_TIME 0.9\n#define PARTICLE_COUNT 120.0\n#define PI 3.14159265359\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,vec2(6.8245,7.1248)))*9.1283);\n}\n\nfloat particle(vec2 uv, float identifier, vec2 anchor, vec2 velocity, float creationTime) {\n    float particleTime = max(0., uTime - creationTime);\n\n    float size = max(0., DIE_TIME - particleTime) * SIZE;\n\n    vec2 velocityOffset = velocity * particleTime;\n    vec2 gravityOffset = GRAV * pow(particleTime, 1.798);\n    \n    vec2 point = anchor + velocityOffset + gravityOffset;\n    \n    float dist = distance(uv, point);\n    float hit = smoothstep(size, 0., dist);\n    \n    return hit;\n}\n\nvec3 currentColor() {\n    float c = uTime * 0.2;\n    float r = sin(c * PI) / 2. + .5;\n    float g = sin((c + .6) * PI) / 2. + .5;\n    float b = sin((c + 1.2) * PI) / 2. + .5;\n    return vec3(r, g, b);\n}\n\nvoid main( )\n{\n    vec2 uv = vTextureCoord;\n    vec3 col = vec3(0.);\n\n    \n    for (float i = 0.0; i < PARTICLE_COUNT; i++) {\n        float seed = SEED + floor(i / PARTICLE_COUNT + uTime);\n\n        vec2 anchor = vec2(uPosx/filterArea.x, uPosy/filterArea.y);\n\n        vec2 velocity = vec2(mix(-.5, .5, rand(vec2(seed, i))), mix(-.5, .5, rand(vec2(i, seed) / 3.)));\n\n        float creationTime = uTime - fract(i / PARTICLE_COUNT + uTime);\n\n      col += particle(uv, 0., anchor, velocity, creationTime) * uColor;\n    }\n\n    col = smoothstep(.6, .9, col);\n\n    vec4 tc = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(col, col.r)*col.r + tc*(1.0 -col.r);\n}",i=function(o){function e(e,i,r,c){void 0===e&&(e=10),void 0===i&&(i=10),void 0===r&&(r=0),void 0===c&&(c={r:1,g:0,b:0}),o.call(this,t,n),this.posx=e,this.posy=i,this.delta=r,this.uniforms.uColor=new Float32Array(3),this._color={r:c.r,g:c.g,b:c.b}}o&&(e.__proto__=o),e.prototype=Object.create(o&&o.prototype),e.prototype.constructor=e;var i={posx:{configurable:!0},color:{configurable:!0},delta:{configurable:!0}};return e.prototype.apply=function(o,e,t,n){this.uniforms.uPosx=this.posx<=0?10:this.posx,this.uniforms.uPosy=this.posy<=0?10:this.posy,this.uniforms.uColor[0]=this._color.r,this.uniforms.uColor[1]=this._color.g,this.uniforms.uColor[2]=this._color.b,o.applyFilter(this,e,t,n)},i.posx.get=function(){return this.uniforms.uPosx},i.posx.set=function(o){this.uniforms.uPosx=o},i.color.get=function(){return this._color},i.color.set=function(o){this._color=o,this.uniforms.uColor[0]=o.r,this.uniforms.uColor[1]=o.g,this.uniforms.uColor[2]=o.b},i.delta.get=function(){return this.uniforms.uTime},i.delta.set=function(o){this.uniforms.uTime=o},Object.defineProperties(e.prototype,i),e}(e.Filter);return o.AmoyBloodSplashFilter=i,o}({},PIXI);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=filter-blood-splash.js.map
