/*!
 * @amoy/filter-blood-splash - v3.0.24
 * Compiled Wed, 27 Nov 2019 03:13:09 UTC
 *
 * @amoy/filter-blood-splash is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@pixi/core');

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;//passed from vect shader \n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;// 2d texture\n\nuniform float uPosx;\nuniform float uPosy;\nuniform float uTime;\nuniform vec3 uColor;\n\n#define SEED 0.12345679\n#define GRAV vec2(0.,-.26)\n#define SIZE 0.024\n#define DIE_TIME 0.9\n#define PARTICLE_COUNT 120.0\n#define PI 3.14159265359\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,vec2(6.8245,7.1248)))*9.1283);\n}\n\nfloat particle(vec2 uv, float identifier, vec2 anchor, vec2 velocity, float creationTime) {\n    float particleTime = max(0., uTime - creationTime);\n\n    float size = max(0., DIE_TIME - particleTime) * SIZE;\n\n    vec2 velocityOffset = velocity * particleTime;\n    vec2 gravityOffset = GRAV * pow(particleTime, 1.798);\n    \n    vec2 point = anchor + velocityOffset + gravityOffset;\n    \n    float dist = distance(uv, point);\n    float hit = smoothstep(size, 0., dist);\n    \n    return hit;\n}\n\nvec3 currentColor() {\n    float c = uTime * 0.2;\n    float r = sin(c * PI) / 2. + .5;\n    float g = sin((c + .6) * PI) / 2. + .5;\n    float b = sin((c + 1.2) * PI) / 2. + .5;\n    return vec3(r, g, b);\n}\n\nvoid main( )\n{\n    vec2 uv = vTextureCoord;\n    vec3 col = vec3(0.);\n\n    \n    for (float i = 0.0; i < PARTICLE_COUNT; i++) {\n        float seed = SEED + floor(i / PARTICLE_COUNT + uTime);\n\n        vec2 anchor = vec2(uPosx/filterArea.x, uPosy/filterArea.y);\n\n        vec2 velocity = vec2(mix(-.5, .5, rand(vec2(seed, i))), mix(-.5, .5, rand(vec2(i, seed) / 3.)));\n\n        float creationTime = uTime - fract(i / PARTICLE_COUNT + uTime);\n\n      col += particle(uv, 0., anchor, velocity, creationTime) * uColor;\n    }\n\n    col = smoothstep(.6, .9, col);\n\n    vec4 tc = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(col, col.r)*col.r + tc*(1.0 -col.r);\n}";

/**
 * @class
 * @see {@link https://www.npmjs.com/package/@amoy/filter-blood-splash}
 * @see {@link https://www.npmjs.com/package/@amoy/filters}
 * @extends PIXI.Filter
 * @memberof AMOY.filters
 * @param {number} [posx=10.0] light  x position
 * @param {number} [posy=10.0] light  y position
 */

var AmoyBloodSplashFilter = /*@__PURE__*/(function (Filter) {
    function AmoyBloodSplashFilter(posx, posy, delta, color) {
        if ( posx === void 0 ) posx = 10.0;
        if ( posy === void 0 ) posy = 10.0;
        if ( delta === void 0 ) delta=0.;
        if ( color === void 0 ) color={r:1.0, g:0, b:0};

        Filter.call(this, vertex, fragment);
        // sub class
        this.posx = posx;
        this.posy = posy;
        this.delta = delta;
        this.uniforms.uColor  = new Float32Array(3);
        this._color = {r:color.r, g:color.g, b:color.b};

    }

    if ( Filter ) AmoyBloodSplashFilter.__proto__ = Filter;
    AmoyBloodSplashFilter.prototype = Object.create( Filter && Filter.prototype );
    AmoyBloodSplashFilter.prototype.constructor = AmoyBloodSplashFilter;

    var prototypeAccessors = { posx: { configurable: true },color: { configurable: true },delta: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    AmoyBloodSplashFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms.uPosx = this.posx <= 0 ? 10.0 : this.posx;
        this.uniforms.uPosy = this.posy <= 0 ? 10.0 : this.posy;
        this.uniforms.uColor[0] = this._color.r;
        this.uniforms.uColor[1] = this._color.g;
        this.uniforms.uColor[2] = this._color.b;
        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * filter area point x
     * @member {number}
     */
    prototypeAccessors.posx.get = function () {
        return this.uniforms.uPosx;
    };

    prototypeAccessors.posx.set = function (value) {
        this.uniforms.uPosx = value;
    };

    /**
     *  the color of blood
     * @member {object}
     */
    prototypeAccessors.color.get = function (){
        return this._color;
    };

    prototypeAccessors.color.set = function (value) {
        this._color = value;
        this.uniforms.uColor[0] = value.r;
        this.uniforms.uColor[1] = value.g;
        this.uniforms.uColor[2] = value.b;
    };

    /**
     * time for animation
     *
     * @member {number}
     * @default 0.0
     */
    prototypeAccessors.delta.get = function () {
        return this.uniforms.uTime;
    };

    prototypeAccessors.delta.set = function (value) {
        this.uniforms.uTime = value;
    };

    Object.defineProperties( AmoyBloodSplashFilter.prototype, prototypeAccessors );

    return AmoyBloodSplashFilter;
}(core.Filter));

exports.AmoyBloodSplashFilter = AmoyBloodSplashFilter;
//# sourceMappingURL=filter-blood-splash.cjs.js.map
