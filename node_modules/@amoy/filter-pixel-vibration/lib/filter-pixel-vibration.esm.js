/*!
 * @amoy/filter-pixel-vibration - v3.0.21
 * Compiled Thu, 21 Nov 2019 07:47:39 UTC
 *
 * @amoy/filter-pixel-vibration is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
import { Filter } from '@pixi/core';

var testVert = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var testFrag = "varying vec2 vTextureCoord;//passed from vect shader \n\nuniform vec4 filterArea;\n\nuniform sampler2D uSampler; // 2d texture\n\nuniform float uIntensity;\nuniform float uBlursize;\nuniform float uThreshold;\n\n#define T(t, c, u, v, m) texture2D(t, c + vec2(u, v), m)\n\nvec4 B(in vec2 C, in sampler2D X, in float m)\n{\n\tvec2 d = m / filterArea.xy;\n    \n    vec4  c = texture2D(X, C, m);\n    c += T(X, C,  d.x, 0.0, m);    \t\n    c += T(X, C, -d.x, 0.0, m);    \t\n    c += T(X, C, 0.0,  d.y, m);    \t\n    c += T(X, C, 0.0, -d.y, m);    \t\n    c += T(X, C,  d.x, d.y, m);    \t\n    c += T(X, C, -d.x, d.y, m);    \t\n    c += T(X, C,  d.x,-d.y, m);    \t\n    c += T(X, C, -d.x,-d.y, m);    \n    return c / 9.0;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a = a / 2;\n        b = b / 2;\n        n = n * 2;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n    vec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use = use / 2;\n        inCol.rgb += a * vec3(v, p3, p1);\n\n        a = float(and(use , 1)); // i == 1;\n        use = use / 2;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use = use / 2;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use = use / 2;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use = use / 2;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use = use / 2;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvec4 mainImage()\n{\n    float t = uThreshold, // threshold\n\t \t  I = uIntensity, // intensity\n          b = uBlursize; // blursize\n\n    vec4 c = texture2D(uSampler, vTextureCoord);//采样\n    vec4 H = clamp(B(vTextureCoord, uSampler, b) - t, 0.0, 1.0) * 1.0 / (1.0 - t); // highlight\n    vec4 imgC = 1.0 - (1.0 - c) * (1.0 - H * I); //Screen Blend Mode\n    \n    imgC = vibrance(imgC, 2.0);\n    return imgC;\n}\n\nvoid main(void)\n{ \n    gl_FragColor = mainImage();\n}";

/**
 * @class
 * @see {@link https://www.npmjs.com/package/@amoy/filter-pixel-vibration}
 * @see {@link https://www.npmjs.com/package/@amoy/filters}
 * @extends PIXI.Filter
 * @memberof AMOY.filters
 * @param {number} [intensity = 3.0] blur strength
 * @param {number} [blursize = 2.0] blur size
 */

var AmoyPixelVibrationFilter = /*@__PURE__*/(function (Filter) {
    function AmoyPixelVibrationFilter(intensity, blursize){
        if ( intensity === void 0 ) intensity = 3.0;
        if ( blursize === void 0 ) blursize = 2.0;

        Filter.call(this, testVert, testFrag);
        this.intensity = intensity;
        this.blursize = blursize;
        this.threshold = 0.5;
    }

    if ( Filter ) AmoyPixelVibrationFilter.__proto__ = Filter;
    AmoyPixelVibrationFilter.prototype = Object.create( Filter && Filter.prototype );
    AmoyPixelVibrationFilter.prototype.constructor = AmoyPixelVibrationFilter;

    var prototypeAccessors = { intensity: { configurable: true },blursize: { configurable: true },threshold: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    AmoyPixelVibrationFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms.uIntensity = this.intensity <= 0 ? 3.0 : this.intensity;
        this.uniforms.uBlursize = this.blursize <= 0 ? 2.0 : this.blursize;
        this.uniforms.uThreshold = this.threshold <= 0 ? 0.0 : this.threshold;
        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * intensity
     *
     * @member {number}
     * @default 3.0
     */
    prototypeAccessors.intensity.get = function () {
        return this.uniforms.uIntensity;
    };

    prototypeAccessors.intensity.set = function (value) {
        this.uniforms.uIntensity = Math.min(Math.max(2.0, value), 6.0);
    };

    /**
     * blursize
     *
     * @member {number}
     * @default 2.0
     */
    prototypeAccessors.blursize.get = function () {
        return this.uniforms.uBlursize;
    };

    prototypeAccessors.blursize.set = function (value) {
        this.uniforms.uBlursize = Math.min(Math.max(2.0, value), 6.0);
    };

    /**
     * threshold
     *
     * @member {number}
     * @default 2.0
     */
    prototypeAccessors.threshold.get = function () {
        return this.uniforms.uThreshold;
    };

    prototypeAccessors.threshold.set = function (value) {
        this.uniforms.uThreshold = Math.min(Math.max(0.0, value), 1.0);
    };

    Object.defineProperties( AmoyPixelVibrationFilter.prototype, prototypeAccessors );

    return AmoyPixelVibrationFilter;
}(Filter));

export { AmoyPixelVibrationFilter };
//# sourceMappingURL=filter-pixel-vibration.esm.js.map
