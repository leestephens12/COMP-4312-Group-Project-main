/*!
 * @amoy/filter-page-curl - v3.0.21
 * Compiled Thu, 21 Nov 2019 07:47:39 UTC
 *
 * @amoy/filter-page-curl is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
import { Texture, Filter } from '@pixi/core';

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;//passed from vect shader \n\nuniform sampler2D uSampler;// 2d texture\nuniform sampler2D nextPageTexture;// 2d texture\n\nuniform vec4 filterArea;\n\nuniform float uPosx;\nuniform float uPosy;\nuniform float uStartPosx;\nuniform float uStartPosy;\nuniform float uRadius;//翻卷半径\nuniform int uFlipmode;//反向翻转模式 0 or 1\n\n\n#define pi 3.14159265359\n//#define uRadius .04\n\n#define iResolution filterArea\n#define iTime uTime\n#define fragColor gl_FragColor\n#define texture texture2D\n\nvoid main(void)\n{\n\tfloat aspect=iResolution.x/iResolution.y;\n\tfloat radius = uRadius;\n\n\tvec2 uv=vTextureCoord*filterArea.xy*vec2(aspect,1.)/iResolution.xy;\n\tvec2 maxuv = filterArea.xy*vec2(aspect,1.)/iResolution.xy;\n\tif(uFlipmode > 0){\n\t\tuv.x = maxuv.x - uv.x;\n\t}else{\n\t\tvec2 maxuv = vec2(1.0);\n\t}\n\t\n\tvec4 virtualMouse=vec4(uPosx,uPosy,uStartPosx,uStartPosy);\n\tvec2 mouse=virtualMouse.xy*vec2(aspect,1.)/iResolution.xy;\n\tvec2 mouseDir=normalize(abs(virtualMouse.zw)-virtualMouse.xy);\n\tvec2 origin=clamp(mouse-mouseDir*mouse.x/mouseDir.x,0.,1.);\n\t\n\tfloat mouseDist=clamp(length(mouse-origin)+(aspect-(abs(virtualMouse.z)/iResolution.x)*aspect)/mouseDir.x,0.,aspect/mouseDir.x);\n\t\n\tif(mouseDir.x<0.)\n\t{\n\t\tmouseDist=distance(mouse,origin);\n\t}\n\t\n\tfloat proj=dot(uv-origin,mouseDir);\n\tfloat dist=proj-mouseDist;\n\t\n\tvec2 linePoint=uv-dist*mouseDir;\n\t\n\tif(dist>radius)\n\t{\n\t\t//下一页面\n\t\tif(uFlipmode > 0){\n\t\t\tuv.x = maxuv.x- uv.x;\n\t\t}\n\t\tfragColor=texture(nextPageTexture,uv*vec2(1./aspect,1.));\n\t\tfragColor.rgb*= clamp(min(.99, .5 + 1. - radius/.04), 1.0, pow(clamp((dist-radius)*14.0,0.,1.),max(.05,5.*radius)));\n\t}\n\telse if(dist>=0.)\n\t{\n\t\t// 圆柱面点映射\n\t\tfloat theta=asin(dist/radius);\n\t\tvec2 p2=linePoint+mouseDir*(pi-theta)*radius;\n\t\tvec2 p1=linePoint+mouseDir*theta*radius;\n\t\tif(p2.x<=aspect&&p2.y<=1.&&p2.x>0.&&p2.y>0.){\n\t\t\tuv = p2;\n\t\t\t//背面页 圆柱面\n\t\t\tif(uFlipmode > 0){\n\t\t\t\tuv = (maxuv- uv*vec2(1./aspect,1.));\n\t\t\t\tuv.y = maxuv.y- uv.y;\n\t\t\t\tuv.x = maxuv.x- uv.x;\n\t\t\t}else{\n\t\t\t\tuv = (1.0- uv*vec2(1./aspect,1.));\n\t\t\t\tuv.y = 1.0- uv.y;\n\t\t\t}\n\t\t\tfragColor = texture(nextPageTexture, uv);\n\t\t\tfragColor.rgb*=clamp(min(.99, .6 + 1. - uRadius/.04), 1.0, pow(clamp((radius-dist)/radius,0.,1.), max(.05,5.*radius)));\n\t\t\tfragColor.a = 1.;\n\t\t}else{\n\t\t\t//corer 圆角\n\t\t\tuv = p1;\n\t\t\tif(uFlipmode > 0){\n\t\t\t\tuv.x = maxuv.x- uv.x;\n\t\t\t}\n\t\t\tfragColor = texture(uSampler, uv * vec2(1. / aspect, 1.));\n\t\t\tfragColor.rgb*=clamp(.94, 1.0, pow(clamp((radius-dist)/radius,0.,1.),max(.05,5.*radius)));\n\t\t}\n\t}\n\telse\n\t{\n\t\tvec2 p=linePoint+mouseDir*(abs(dist)+pi*radius);\n\t\tif(p.x<=aspect&&p.y<=1.&&p.x>0.&&p.y>0.&&length(mouseDir)>0.){\n\t\t\tuv = p ;\n\t\t\t// 背面页平面区域\n\t\t\tif(uFlipmode > 0){\n\t\t\t\tuv = (maxuv - uv*vec2(1./aspect,1.));\n\t\t\t\tuv.y = maxuv.y - uv.y;\n\t\t\t\tuv.x = maxuv.x- uv.x;\n\t\t\t}else{\n\t\t\t\tuv = (1.0 - uv*vec2(1./aspect,1.));\n\t\t\t\tuv.y = 1.0 - uv.y;\n\t\t\t}\n\t\t\tfragColor=texture(nextPageTexture,uv);\n\t\t\tfragColor.a = 1.;\n\t\t}else{\n\t\t\t// 正面页面\n\t\t\tif(uFlipmode > 0){\n\t\t\t\tuv.x = maxuv.x- uv.x;\n\t\t\t}\n\t\t\tfragColor=texture(uSampler,uv*vec2(1./aspect,1.));\n\t\t}\n\t\t\n\t}\n}";

/**
 * @class
 * @see {@link https://www.npmjs.com/package/@amoy/filter-page-curl}
 * @see {@link https://www.npmjs.com/package/@amoy/filters}
 * @extends PIXI.Filter
 * @memberof AMOY.filters
 * @param {number} [posx=0.] drag moving x position
 * @param {number} [posy=0.] drag moving y position
 * @param {number} [startPosx=0.] drag start x position
 * @param {number} [startPosy=0.] drag start y position
 */

var AmoyPageCurlFilter = /*@__PURE__*/(function (Filter) {
    function AmoyPageCurlFilter(posx, posy, startPosx, startPosy, nextPageTexture, radius, flipMode) {
        if ( posx === void 0 ) posx = 0.0;
        if ( posy === void 0 ) posy = 0.0;
        if ( startPosx === void 0 ) startPosx = 0.;
        if ( startPosy === void 0 ) startPosy = 0.0;
        if ( radius === void 0 ) radius=0.04;
        if ( flipMode === void 0 ) flipMode=false;

        Filter.call(this, vertex, fragment);
        // sub class
        this.posx = posx;
        this.posy = posy;

        this._size = 0;
        this._sliceSize = 0;
        this._slicePixelSize = 0;
        this._sliceInnerSize = 0;
        this._flipMode = flipMode;

        this._scaleMode = null;

        this.radius = radius;

        this.startPosx = startPosx;
        this.startPosy = startPosy;

        this.nextPageTexture = nextPageTexture;
    }

    if ( Filter ) AmoyPageCurlFilter.__proto__ = Filter;
    AmoyPageCurlFilter.prototype = Object.create( Filter && Filter.prototype );
    AmoyPageCurlFilter.prototype.constructor = AmoyPageCurlFilter;

    var prototypeAccessors = { flipMode: { configurable: true },posx: { configurable: true },radius: { configurable: true },posy: { configurable: true },startPosx: { configurable: true },startPosy: { configurable: true },nextPageTexture: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    AmoyPageCurlFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms.uPosx = this.posx <= 0 ? 0.0 : this.posx;
        this.uniforms.uPosy = this.posy <= 0 ? 0.0 : this.posy;
        this.uniforms.uRadius = this.radius;
        this.uniforms.uFlipmode = this._flipMode ? 1:0;
        this.uniforms.uStartPosx = this.startPosx <= 0 ? 0.0 : this.startPosx;
        this.uniforms.uStartPosy = this.startPosy <= 0 ? 0.0 : this.startPosy;

        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * current pos x
     */
    prototypeAccessors.flipMode.get = function () {
        return this.uFlipmode.uFlipMode;
    };

    prototypeAccessors.flipMode.set = function (value) {
        this._flipMode = value;
        this.uniforms.uFlipmode = this._flipMode ? 1:0;
    };

    /**
     * current pos x
     */
    prototypeAccessors.posx.get = function () {
        return this.uniforms.uPosx;
    };

    prototypeAccessors.posx.set = function (value) {
        this.uniforms.uPosx = value;
    };

    /**
     * current pos x
     */
    prototypeAccessors.radius.get = function () {
        return this.uniforms.uRadius;
    };

    prototypeAccessors.radius.set = function (value) {
        this.uniforms.uRadius = Math.max(Math.min(value, 0.04), 0.000001);
    };


    /**
     * current pos y
     */
    prototypeAccessors.posy.get = function () {
        return this.uniforms.uPosy;
    };

    prototypeAccessors.posy.set = function (value) {
        this.uniforms.uPosy = value;
    };

    /**
     * start pos x
     */
    prototypeAccessors.startPosx.get = function () {
        return this.uniforms.uStartPosx;
    };

    prototypeAccessors.startPosx.set = function (value) {
        this.uniforms.uStartPosx = value;
    };

    /**
     * start pos y
     */
    prototypeAccessors.startPosy.get = function () {
        return this.uniforms.uStartPosy;
    };

    prototypeAccessors.startPosy.set = function (value) {
        this.uniforms.uStartPosy = value;
    };

    /**
     * the nextPageTexture texture
     * @member {PIXI.Texture}
     */
    prototypeAccessors.nextPageTexture.get = function () {
        return this._nextPageTexture;
    };
    prototypeAccessors.nextPageTexture.set = function (nextPageTexture) {
        if (!(nextPageTexture instanceof Texture)) {
            nextPageTexture = Texture.from(nextPageTexture);
        }
        if (nextPageTexture && nextPageTexture.baseTexture) {
            nextPageTexture.baseTexture.scaleMode = this._scaleMode;
            nextPageTexture.baseTexture.mipmap = false;

            this._size = nextPageTexture.height;
            this._sliceSize = 1 / this._size;
            this._slicePixelSize = this._sliceSize / this._size;
            this._sliceInnerSize = this._slicePixelSize * (this._size - 1);

            this.uniforms._size = this._size;
            this.uniforms._sliceSize = this._sliceSize;
            this.uniforms._slicePixelSize = this._slicePixelSize;
            this.uniforms._sliceInnerSize = this._sliceInnerSize;

            this.uniforms.nextPageTexture = nextPageTexture;
        }

        this._nextPageTexture = nextPageTexture;
    };

    /**
     * If the nextPageTexture is based on canvas , and the content of canvas has changed,
     *   then call `updateColorMap` for update texture.
     */
    AmoyPageCurlFilter.prototype.updateNextPageTexture = function updateNextPageTexture () {
        var texture = this._nextPageTexture;

        if (texture && texture.baseTexture) {
            texture._updateID++;
            texture.baseTexture.emit('update', texture.baseTexture);

            this.nextPageTexture = texture;
        }
    };

    /**
     * Destroys this filter
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture of nextPageTexture as well
     */
    AmoyPageCurlFilter.prototype.destroy = function destroy (destroyBase) {
        if (this._nextPageTexture) {
            this._nextPageTexture.destroy(destroyBase);
        }
        Filter.prototype.destroy.call(this);
    };

    Object.defineProperties( AmoyPageCurlFilter.prototype, prototypeAccessors );

    return AmoyPageCurlFilter;
}(Filter));

export { AmoyPageCurlFilter };
//# sourceMappingURL=filter-page-curl.esm.js.map
