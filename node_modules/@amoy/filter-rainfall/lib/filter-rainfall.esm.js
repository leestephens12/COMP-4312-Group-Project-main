/*!
 * @amoy/filter-rainfall - v3.0.24
 * Compiled Wed, 27 Nov 2019 03:13:09 UTC
 *
 * @amoy/filter-rainfall is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
import { Filter } from '@pixi/core';

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;//passed from vect shader \nuniform sampler2D uSampler; // 2d texture\n\nuniform vec4 filterArea;\n//uniform vec2 dimensions;\n\nuniform float uTime;\nuniform float uRainR; // Radius of the rain\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec4 image()\n{\n\n\tvec2 uv1 = (vTextureCoord * filterArea.xy) / filterArea.y * uRainR;\n    \n    vec2 p0 = floor(uv1);\n\n    vec2 circles = vec2(0.);\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 hsh = hash22(pi);\n            #else\n            vec2 hsh = pi;\n            #endif\n            vec2 p = pi + hash22(hsh);\n\n            float t = fract(0.3*uTime + hash12(hsh));\n            vec2 v = p - uv1;\n            float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n            float h = 1e-3;\n            float d1 = d - h;\n            float d2 = d + h;\n            float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n            float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n            circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n        }\n    }\n    int r = (MAX_RADIUS*2+1);\n    circles /= float(r*r);\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*uTime + 0.5)*2.-1.)));\n    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n\n    vec3 color = texture2D(uSampler, vTextureCoord).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid main(void)\n{\n    gl_FragColor = image();\n}";

/**
 * The AmoyRainfallFilter applies the effect to an object.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/AmoyRainfallFilter.gif)
 *
 * @class
 * @see {@link https://www.npmjs.com/package/@amoy/filter-rainfall}
 * @see {@link https://www.npmjs.com/package/@amoy/filters}
 * @extends PIXI.Filter
 * @memberof AMOY.filters
 * @param {number} [rainR=2.0] rain numbers
 * @param {number} {delta=0} time for shader animation
 */

var AmoyRainfallFilter = /*@__PURE__*/(function (Filter) {
    function AmoyRainfallFilter(rainR, delta){
        if ( rainR === void 0 ) rainR = 2.0;
        if ( delta === void 0 ) delta = 0.0;

        Filter.call(this, vertex, fragment);
        this.rainR = rainR;
        this.delta = delta;
    }

    if ( Filter ) AmoyRainfallFilter.__proto__ = Filter;
    AmoyRainfallFilter.prototype = Object.create( Filter && Filter.prototype );
    AmoyRainfallFilter.prototype.constructor = AmoyRainfallFilter;

    var prototypeAccessors = { rainR: { configurable: true },delta: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    AmoyRainfallFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms.uRainR = this.rainR <= 0 ? 2.0 : this.rainR;
        this.uniforms.uTime = this.delta <= 0 ? 2.0 : this.delta;

        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * rain radias size
     *
     * @member {number}
     * @default 2.0
     */
    prototypeAccessors.rainR.get = function () {
        return this.uniforms.uRainR;
    };

    prototypeAccessors.rainR.set = function (value) {
        this.uniforms.uRainR = value;
    };

    /**
     * time for animation
     *
     * @member {number}
     * @default 0.0
     */
    prototypeAccessors.delta.get = function () {
        return this.uniforms.uTime;
    };

    prototypeAccessors.delta.set = function (value) {
        this.uniforms.uTime = value;
    };

    Object.defineProperties( AmoyRainfallFilter.prototype, prototypeAccessors );

    return AmoyRainfallFilter;
}(Filter));

export { AmoyRainfallFilter };
//# sourceMappingURL=filter-rainfall.esm.js.map
