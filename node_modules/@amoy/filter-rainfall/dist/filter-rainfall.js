/*!
 * @amoy/filter-rainfall - v3.0.24
 * Compiled Wed, 27 Nov 2019 03:13:09 UTC
 *
 * @amoy/filter-rainfall is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(n,t){"use strict";var e="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",i="varying vec2 vTextureCoord;//passed from vect shader \nuniform sampler2D uSampler; // 2d texture\n\nuniform vec4 filterArea;\n//uniform vec2 dimensions;\n\nuniform float uTime;\nuniform float uRainR; // Radius of the rain\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec4 image()\n{\n\n\tvec2 uv1 = (vTextureCoord * filterArea.xy) / filterArea.y * uRainR;\n    \n    vec2 p0 = floor(uv1);\n\n    vec2 circles = vec2(0.);\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 hsh = hash22(pi);\n            #else\n            vec2 hsh = pi;\n            #endif\n            vec2 p = pi + hash22(hsh);\n\n            float t = fract(0.3*uTime + hash12(hsh));\n            vec2 v = p - uv1;\n            float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n            float h = 1e-3;\n            float d1 = d - h;\n            float d2 = d + h;\n            float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n            float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n            circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n        }\n    }\n    int r = (MAX_RADIUS*2+1);\n    circles /= float(r*r);\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*uTime + 0.5)*2.-1.)));\n    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n\n    vec3 color = texture2D(uSampler, vTextureCoord).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid main(void)\n{\n    gl_FragColor = image();\n}",r=function(n){function t(t,r){void 0===t&&(t=2),void 0===r&&(r=0),n.call(this,e,i),this.rainR=t,this.delta=r}n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t;var r={rainR:{configurable:!0},delta:{configurable:!0}};return t.prototype.apply=function(n,t,e,i){this.uniforms.uRainR=this.rainR<=0?2:this.rainR,this.uniforms.uTime=this.delta<=0?2:this.delta,n.applyFilter(this,t,e,i)},r.rainR.get=function(){return this.uniforms.uRainR},r.rainR.set=function(n){this.uniforms.uRainR=n},r.delta.get=function(){return this.uniforms.uTime},r.delta.set=function(n){this.uniforms.uTime=n},Object.defineProperties(t.prototype,r),t}(t.Filter);return n.AmoyRainfallFilter=r,n}({},PIXI);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=filter-rainfall.js.map
